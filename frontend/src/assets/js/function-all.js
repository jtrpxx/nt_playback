export function getCookie(name) {
    if (!name || typeof document === 'undefined') return null
    const v = document.cookie.match('(^|;)\\s*' + name + '\\s*=\\s*([^;]+)')
    return v ? v.pop() : null
}
// ensure custom styles for notify/toast exist
function ensureNotifyStyles() {
  if (typeof document === 'undefined') return
  if (document.getElementById('notify-custom-styles')) return
  const css = `
  .swal2-custom-popup { border-radius: 10px; padding: 28px; box-shadow: 0 10px 30px rgba(0,0,0,0.12); font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial; }
  .swal2-custom-title { font-size: 28px; font-weight: 600; color: #333; margin-bottom: 6px; }
  .swal2-custom-content { color: #6b7280; font-size: 16px; line-height: 1.6; margin-bottom: 18px; }
  .swal2-custom-confirm { background: linear-gradient(180deg,#4f86ff,#2b6bff) !important; color: #fff !important; border-radius: 22px !important; padding: 8px 22px !important; box-shadow: 0 3px 0 rgba(0,0,0,0.12); }

  /* Toast tweaks */
  .toast { position: fixed; right: 18px; top: 18px; display: flex; align-items: center; gap: 12px; background: rgba(0,0,0,0.78); color: #fff; padding: 12px 14px; border-radius: 8px; box-shadow: 0 8px 24px rgba(0,0,0,0.12); max-width: 380px; z-index: 9999; }
  .toast .title { font-weight: 700; font-size: 14px; }
  .toast .message { font-size: 13px; color: rgba(255,255,255,0.95); }
  .toast.success { background: linear-gradient(90deg,#36b37e,#2ea36a); }
  .toast.error { background: linear-gradient(90deg,#ff6b6b,#ff4b4b); }
  .toast .icon { font-size: 18px; }
  .toast-progress { height: 3px; background: rgba(255,255,255,0.12); border-radius: 2px; overflow: hidden; margin-top: 8px; }
  .toast-progress-bar { height: 100%; background: rgba(255,255,255,0.9); width: 100%; }
  `
  const style = document.createElement('style')
  style.id = 'notify-custom-styles'
  style.appendChild(document.createTextNode(css))
  document.head.appendChild(style)
}
export function showToast(titleOrMessage, maybeTypeOrMessage = '', maybeType) {
  try {
    const types = ['success', 'error', 'info', 'warning']
    let title = ''
    let message = ''
    let type = 'success'

    if (maybeType !== undefined) {
      // called as showToast(title, message, type)
      title = String(titleOrMessage || '')
      message = String(maybeTypeOrMessage || '')
      type = String(maybeType || 'success')
    } else {
      if (types.includes(String(maybeTypeOrMessage))) {
        // called as showToast(message, type)
        title = ''
        message = String(titleOrMessage || '')
        type = String(maybeTypeOrMessage)
      } else {
        // called as showToast(title, message) or showToast(message)
        title = String(titleOrMessage || '')
        message = String(maybeTypeOrMessage || '')
        type = 'success'
      }
    }

    const el = document.createElement('div')
    el.className = `toast ${type || ''}`

    const icon = document.createElement('div')
    icon.className = 'icon'
    // ensure glyph color is white for visibility against colored backgrounds
    icon.style.color = '#fff'
    // small vertical nudge to better center glyphs
    // mark icon as decorative for screen readers
    icon.setAttribute('aria-hidden', 'true')
    // set glyph per type; use Font Awesome for error for a consistent X mark
    const glyphMap = {
      success: { char: '✓' },
      error: { fa: 'fa-solid fa-xmark' },
      info: { char: 'ℹ' },
      warning: { char: '!' }
    }
    const map = glyphMap[type] || glyphMap.success
    if (map.fa) {
      icon.innerHTML = `<i class="${map.fa}" aria-hidden="true" style="margin-top: 2px;"></i>`
    } else {
      icon.textContent = map.char
    }

    const content = document.createElement('div')
    content.className = 'content'
    if (title) {
      const t = document.createElement('div')
      t.className = 'title'
      t.textContent = title
      content.appendChild(t)
    }
    if (message) {
      const m = document.createElement('div')
      m.className = 'message'
      // render HTML when backend sends markup (e.g. <br>) otherwise use textContent
      try {
        if (/<\/?[a-z][\s\S]*>/i.test(message)) m.innerHTML = message
        else m.textContent = message
      } catch (e) { m.textContent = String(message) }
      content.appendChild(m)
    }

    el.appendChild(icon)
    el.appendChild(content)
    // insert at top so newest is on top
    const first = document.body.querySelector('.toast')
    if (first) document.body.insertBefore(el, first)
    else document.body.appendChild(el)

    // show toast and set up timed hide/remove with progress bar and hover-pause
    requestAnimationFrame(() => el.classList.add('show'))

    const hideDelay = 3200 // ms until hide
    const removeDelay = 3800 // ms until DOM removal

    // add progress bar element
    const progressWrap = document.createElement('div')
    progressWrap.className = 'toast-progress'
    const progressBar = document.createElement('div')
    progressBar.className = 'toast-progress-bar'
    progressWrap.appendChild(progressBar)
    el.appendChild(progressWrap)

    let remaining = hideDelay
    let progStart = Date.now()
    let progDuration = remaining
    let hideTimeout = null
    let removeTimeout = null
    let rafId = null

    function rafLoop() {
      const now = Date.now()
      const elapsed = now - progStart
      const pct = Math.max(0, Math.min(100, ((progDuration - elapsed) / progDuration) * 100))
      progressBar.style.width = pct + '%'
      if (elapsed < progDuration) rafId = requestAnimationFrame(rafLoop)
    }

    function startTimers(ms) {
      // set up hide and remove timeouts relative to now
      hideTimeout = setTimeout(() => {
        el.classList.remove('show')
      }, ms)
      const removeAfter = ms + (removeDelay - hideDelay)
      removeTimeout = setTimeout(() => { try { el.remove() } catch (e) {} }, removeAfter)
      // start progress
      progStart = Date.now()
      progDuration = Math.max(1, ms)
      if (rafId) cancelAnimationFrame(rafId)
      rafId = requestAnimationFrame(rafLoop)
    }

    // begin
    startTimers(remaining)

    // pause on hover: clear timers and stop RAF
    el.addEventListener('mouseenter', () => {
      if (hideTimeout) { clearTimeout(hideTimeout); hideTimeout = null }
      if (removeTimeout) { clearTimeout(removeTimeout); removeTimeout = null }
      if (rafId) { cancelAnimationFrame(rafId); rafId = null }
      const now = Date.now()
      const elapsed = now - progStart
      remaining = Math.max(0, progDuration - elapsed)
    })

    // resume on mouseleave
    el.addEventListener('mouseleave', () => {
      startTimers(remaining)
    })
  } catch (e) { console.warn('showToast failed', e) }
}

export function notification (title, text, icon, showCancelButton){

}

export async function exportTableToFormat(format, type = 'audio', opts = {}) {
  try {
    const rows = Array.isArray(opts.rows) ? opts.rows : []
    const columns = Array.isArray(opts.columns) ? opts.columns : []
    const startIndex = typeof opts.startIndex === 'number' ? opts.startIndex : 0
    const rangeStart = (startIndex || 0) + 1
    const rangeEnd = (startIndex || 0) + (rows.length || 0)

    const hdrs = columns.map(c => c.label || c.key)

    const exportData = rows.map((row, rIdx) => {
      return columns.map((col) => {
        if (col.isIndex) return (startIndex || 0) + rIdx + 1
        const key = col.key
        let val = row && (row[key] !== undefined ? row[key] : '')
        if (val === null || val === undefined) return ''
        return String(val)
      })
    })

    // Allow caller to override the filename prefix via opts.fileNamePrefix
    let fileTypeName = ''
    if (opts && opts.fileNamePrefix) {
      fileTypeName = String(opts.fileNamePrefix)
      if (!fileTypeName.endsWith('_')) fileTypeName += '_'
    } else {
      if (type === 'audit') fileTypeName = 'audit-records_'
      else if (type === 'audio') fileTypeName = 'audio-records_'
      else fileTypeName = (type ? String(type) + '_' : '')
    }

    // Excel (HTML-based .xls)
    if (format === 'excel') {
      const headerBg = '#2980b9'
      const callDirColorMap = {
        'Incoming': '#baf3c7', 'Inbound': '#baf3c7', 'Outgoing': '#add8e6', 'Outbound': '#add8e6', 'Internal': '#fdedbe', 'Block': '#ff7878', 'Tandem': '#add8e6', 'External': '#f0f0f0'
      }
      const statusColorMap = { 'success': '#baf3c7', 'error': '#ff7878' }

      let html = '<html><head><meta charset="UTF-8"></head><body>'
      html += '<table border="1" cellspacing="0" cellpadding="0">'
      html += '<tr>'
      html += '<td colspan="' + hdrs.length + '" style="text-align:left;font-size:28px;color:#2980b9;padding:8px;font-weight:bold;">' + (type === 'audio' ? 'Audio Records' : 'Audit Log') + '</td>'
      html += '</tr>'
      html += '<tr>'
      html += '<td colspan="' + hdrs.length + '" style="border-bottom:2px solid #2980b9;padding:0;margin:0;">&nbsp;</td>'
      html += '</tr>'
      html += '<thead><tr>'
      hdrs.forEach(h => { html += '<th style="background-color:' + headerBg + ';color:#ffffff;padding:8px;">' + (h || '') + '</th>' })
      html += '</tr></thead><tbody>'

      const custNumIndex = hdrs.findIndex(h => String(h).toLowerCase().includes('customer') || String(h).toLowerCase().includes('number'))
      const extIndex = hdrs.findIndex(h => String(h).toLowerCase().includes('extension') || String(h).toLowerCase().includes('ext'))
      const callDirIndex = hdrs.findIndex(h => String(h).toLowerCase().includes('call direction'))
      const statusIndex = hdrs.findIndex(h => String(h).toLowerCase().includes('status'))

      exportData.forEach(row => {
        html += '<tr>'
        row.forEach((cell, cellIndex) => {
          const text = (cell === null || cell === undefined) ? '' : String(cell).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')
          let cellStyle = ''
          if (callDirIndex >= 0 && cellIndex === callDirIndex) {
            const bg = callDirColorMap[text] || '#ffffff'
            cellStyle += 'background-color:' + bg + ';'
          } else if (statusIndex >= 0 && cellIndex === statusIndex) {
            const bg = statusColorMap[text] || '#ffffff'
            cellStyle += 'background-color:' + bg + ';'
          }
          if ((custNumIndex >= 0 && cellIndex === custNumIndex) || (extIndex >= 0 && cellIndex === extIndex)) {
            cellStyle += 'text-align:right;mso-number-format:\\@;'
          }
          html += '<td style="' + cellStyle + '">' + text + '</td>'
        })
        html += '</tr>'
      })

      html += '</tbody></table></body></html>'

      const blob = new Blob([html], { type: 'application/vnd.ms-excel' })
      const dateStr = new Date().toISOString().slice(0, 10)
      const fileName = fileTypeName + dateStr + '_' + rangeStart + '-' + rangeEnd + '.xls'
      if (window.navigator && window.navigator.msSaveOrOpenBlob) window.navigator.msSaveOrOpenBlob(blob, fileName)
      else {
        const url = URL.createObjectURL(blob)
        const a = document.createElement('a')
        a.href = url
        a.download = fileName
        document.body.appendChild(a)
        a.click()
        a.remove()
        setTimeout(() => URL.revokeObjectURL(url), 3000)
      }
      return
    }

    // CSV
    if (format === 'csv') {
      const BOM = '\uFEFF'
      const escapeCsv = (v) => {
        if (v === null || v === undefined) return ''
        const s = String(v)
        return '"' + s.replace(/"/g, '""') + '"'
      }
      const csvLines = []
      csvLines.push(hdrs.map(h => escapeCsv(h)).join(','))
      exportData.forEach(r => {
        csvLines.push(r.map(cell => escapeCsv(cell)).join(','))
      })
      const csvContent = BOM + csvLines.join('\r\n')
      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' })
      const dateStr = new Date().toISOString().slice(0, 10)
      const fileName = fileTypeName + dateStr + '_' + rangeStart + '-' + rangeEnd + '.csv'
      if (window.navigator && window.navigator.msSaveOrOpenBlob) window.navigator.msSaveOrOpenBlob(blob, fileName)
      else {
        const url = URL.createObjectURL(blob)
        const a = document.createElement('a')
        a.href = url
        a.download = fileName
        document.body.appendChild(a)
        a.click()
        a.remove()
        setTimeout(() => URL.revokeObjectURL(url), 3000)
      }
      return
    }

    // PDF using jsPDF + autoTable (expects window.jspdf and autoTable plugin available)
    if (format === 'pdf') {
      const { jsPDF } = window.jspdf || {}
      if (!jsPDF) {
        console.error('jsPDF not available')
        return
      }
      const doc = new jsPDF({ orientation: 'landscape', unit: 'mm', format: 'a4' })
      const titleText = (type === 'audio') ? 'Audio Records' : 'Audit Log'

      const descIndex = hdrs.findIndex(h => String(h).toLowerCase().includes('description'))
      const fileNameIndex = hdrs.findIndex(h => String(h).toLowerCase().includes('file name'))
      const callDirIndex = hdrs.findIndex(h => String(h).toLowerCase().includes('call direction'))
      const statusIndex = hdrs.findIndex(h => String(h).toLowerCase().includes('status'))

      const columnStyles = {}
      if (descIndex >= 0) columnStyles[descIndex] = { cellWidth: 70 }
      if (fileNameIndex >= 0) columnStyles[fileNameIndex] = { cellWidth: 60 }

      const callDirColorMap = {
        'Incoming': { bg: [186,243,199], text: [23,21,21] }, 'Inbound': { bg: [186,243,199], text: [23,21,21] }, 'Outgoing': { bg: [173,216,230], text: [23,21,21] }, 'Outbound': { bg: [173,216,230], text: [23,21,21] }, 'Internal': { bg: [253,237,190], text: [23,21,21] }, 'Block': { bg: [255,120,120], text: [255,255,255] }, 'Tandem': { bg: [173,216,230], text: [255,255,255] }, 'External': { bg: [240,240,240], text: [23,21,21] }
      }
      const statusColorMap = { 'success': { bg: [186,243,199], text: [23,21,21] }, 'error': { bg: [255,120,120], text: [255,255,255] } }

      doc.autoTable({
        head: [hdrs],
        body: exportData,
        startY: 22,
        margin: { top: 22, left: 14, right: 14 },
        theme: 'grid',
        styles: { font: 'helvetica', fontSize: 7.5, cellPadding: 2, overflow: 'linebreak' },
        headStyles: { fillColor: [41,128,185], textColor: [255,255,255], fontSize: 8.5, fontStyle: 'bold' },
        columnStyles: columnStyles,
        tableWidth: 'auto',
        didDrawPage: function (data) {
          const pageWidth = doc.internal.pageSize.getWidth ? doc.internal.pageSize.getWidth() : doc.internal.pageSize.width
          const left = data.settings && data.settings.margin && data.settings.margin.left !== undefined ? data.settings.margin.left : 14
          const right = data.settings && data.settings.margin && data.settings.margin.right !== undefined ? data.settings.margin.right : 14
          const lineStartX = left
          const lineEndX = pageWidth - right
          doc.setFontSize(16)
          doc.setTextColor(41,128,185)
          doc.text(String(titleText), left, 12)
          const pageNum = (typeof data.pageNumber !== 'undefined') ? data.pageNumber : doc.internal.getNumberOfPages()
          doc.setFontSize(10)
          doc.setTextColor(41,128,185)
          if (doc.textAlign) doc.text('Page ' + pageNum, lineEndX, 12, { align: 'right' })
          else doc.text('Page ' + pageNum, lineEndX, 12, null, null, 'right')
          doc.setDrawColor(41,128,185)
          doc.line(lineStartX, 16, lineEndX, 16)
        },
        didParseCell: function (data) {
          const custNumIndex = hdrs.findIndex(h => String(h).toLowerCase().includes('customer') || String(h).toLowerCase().includes('number'))
          const extIndex = hdrs.findIndex(h => String(h).toLowerCase().includes('extension') || String(h).toLowerCase().includes('ext'))
          if ((custNumIndex >= 0 && data.column.index === custNumIndex) || (extIndex >= 0 && data.column.index === extIndex)) data.cell.styles.halign = 'right'
          if (callDirIndex >= 0 && data.column.index === callDirIndex && data.section === 'body') {
            const cellValue = data.cell.text[0]
            const colorInfo = callDirColorMap[cellValue]
            if (colorInfo) { data.cell.styles.fillColor = colorInfo.bg; data.cell.styles.textColor = colorInfo.text }
          }
          if (statusIndex >= 0 && data.column.index === statusIndex && data.section === 'body') {
            const cellValue = data.cell.text[0]
            const colorInfo = statusColorMap[cellValue]
            if (colorInfo) { data.cell.styles.fillColor = colorInfo.bg; data.cell.styles.textColor = colorInfo.text }
          }
        }
      })

      const dateStr = new Date().toISOString().slice(0, 10)
      const fileName = fileTypeName + dateStr + '_' + rangeStart + '-' + rangeEnd + '.pdf'
      doc.save(fileName)
      return
    }
  } catch (err) {
    console.error('exportTableToFormat error', err)
  }
}

export async function confirmDelete(title = 'Are you sure?', text = "You won't be able to revert this!", confirmButtonText = 'Yes, delete it!') {
    const swalLib = (typeof Swal !== 'undefined' && Swal) || (typeof window !== 'undefined' && (window.Swal || window.Sweetalert2 || window.SweetAlert || window.sweetAlert))

    if (swalLib && typeof swalLib.fire === 'function') {
        const result = await swalLib.fire({
            title: title,
            text: text,
            icon: 'warning',
            showCancelButton: true,
            confirmButtonColor: '#3085d6',
            cancelButtonColor: '#d33',
            confirmButtonText: confirmButtonText
        })
        return !!(result && result.isConfirmed)
    } else {
        return window.confirm(`${title} ${text}`)
    }
}

export async function notify(title, message, type = 'success') {
    const swalLib = (typeof Swal !== 'undefined' && Swal) || (typeof window !== 'undefined' && (window.Swal || window.Sweetalert2 || window.SweetAlert || window.sweetAlert))

    if (swalLib && typeof swalLib.fire === 'function') {
      ensureNotifyStyles()
      const hasHtml = /<\/?[a-z][\s\S]*>/i.test(String(message || ''))
      const opts = {
        title: title || undefined,
        icon: type,
        confirmButtonColor: '#3085d6',
        confirmButtonText: 'OK',
        allowOutsideClick: false,
        customClass: { popup: 'swal2-custom-popup', title: 'swal2-custom-title', content: 'swal2-custom-content', confirmButton: 'swal2-custom-confirm' }
      }
      if (hasHtml) opts.html = message
      else opts.text = message
      await swalLib.fire(opts)
    } else {
      ensureNotifyStyles()
      showToast(title, message, type)
    }
}

